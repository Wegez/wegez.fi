<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake</title>
  <style>
    html,body{margin:0;padding:0;height:100%;display:flex;justify-content:center;align-items:flex-start;background:#111;font-family:sans-serif;color:#eee}
    .wrap{margin-top:20px;display:flex;flex-direction:column;align-items:center;gap:10px}
    #score{font-size:24px;font-weight:600;margin-bottom:4px}
    canvas{background:#000;border-radius:14px;touch-action:none;display:block}
    button{padding:8px 16px;border:0;border-radius:8px;background:#2e7d32;color:white;font-size:16px}
    
    /* Container to position the overlay over the canvas */
    .canvas-container {
      position: relative;
      border-radius: 14px;
      overflow: hidden; 
    }
    
    /* Style for the Game Over overlay */
    .game-over-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%; /* Uses 100% of the parent .canvas-container */
      height: 100%; /* Uses 100% of the parent .canvas-container */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      text-align: center;
      font-size: 36px;
      font-weight: bold;
      pointer-events: none;
      z-index: 10;
    }
    .game-over-text {
      font-size: 48px;
      margin-bottom: 10px;
    }
    .final-score-text {
      font-size: 28px;
      color: #79f;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div id="score">Score: 0</div>
  <div class="canvas-container">
    <canvas id="c"></canvas>
    <div id="gameOverOverlay" class="game-over-overlay" style="display: none;">
      <div class="game-over-text">GAME OVER</div>
      <div id="finalScore" class="final-score-text">Score: 0</div>
    </div>
  </div>
  <button id="restart">Restart</button>
</div>

<script>
const CELL=20,COLS=20,ROWS=28,SPEED=8,QUEUE_MAX=6;
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
canvas.width=COLS*CELL;canvas.height=ROWS*CELL;
const scoreEl=document.getElementById('score');
const restartBtn=document.getElementById('restart');
const gameOverOverlay=document.getElementById('gameOverOverlay');
const finalScoreEl=document.getElementById('finalScore');

let snake,dir,queue,food,score,running,last;

function reset(){
  snake=[{x:10,y:14},{x:9,y:14},{x:8,y:14}];
  dir={x:1,y:0};
  queue=[];
  food=randFood();
  score=0;
  running=true;
  last=0;
  scoreEl.textContent='Score: '+score;
  gameOverOverlay.style.display = 'none'; // Hide game over overlay
}

function randFood(){
  let f;
  do{
    f={x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)};
  }while(snake.some(s=>s.x===f.x&&s.y===f.y));
  return f;
}

function pushDir(x,y){ if(queue.length<QUEUE_MAX) queue.push({x,y}); }

function step(){
  while(queue.length){
    const n=queue.shift();
    if(!(n.x===-dir.x&&n.y===-dir.y)){dir=n;break;}
  }
  const h={x:snake[0].x+dir.x,y:snake[0].y+dir.y};

  if(h.x<0||h.x>=COLS||h.y<0||h.y>=ROWS) return gameOver();
  if(snake.some(s=>s.x===h.x&&s.y===h.y)) return gameOver();

  snake.unshift(h);
  if(h.x===food.x&&h.y===food.y){
    score++;scoreEl.textContent='Score: '+score;
    food=randFood();
  } else snake.pop();
}

function draw(){
  ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle='#f4a261';
  ctx.fillRect(food.x*CELL+2,food.y*CELL+2,CELL-4,CELL-4);

  for(let i=0;i<snake.length;i++){
    ctx.fillStyle=i===0?'#79f':'#4ab3ff';
    ctx.fillRect(snake[i].x*CELL+1,snake[i].y*CELL+1,CELL-2,CELL-2);
  }

  drawRoundedBorder(ctx,0,0,canvas.width,canvas.height,14);
}

function drawRoundedBorder(ctx,x,y,w,h,r){
  ctx.lineWidth=8;
  ctx.strokeStyle='#123';
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.stroke();
}

function loop(t){
  if(!last) last=t;
  const dt = t - last; // Calculate the time elapsed since the last frame
  const frameDelay = 1000 / SPEED; // Time required between steps in ms

  // Only step if the game is running AND enough time has passed
  if(running && dt > frameDelay){
    step();
    draw();
    // Adjust last to smooth out timing issues for consistent speed
    last = t - (dt % frameDelay); 
  }
  requestAnimationFrame(loop);
}

function gameOver(){
  running=false;
  finalScoreEl.textContent='Score: '+score;
  gameOverOverlay.style.display = 'flex'; // Show game over overlay
}

window.addEventListener('keydown',e=>{
  const key = e.key.toLowerCase();
  
  // Prevent default browser actions (like scrolling) for game keys
  if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
    e.preventDefault(); 
  }

  // Handle movement inputs
  if(key==='arrowup' || key==='w')pushDir(0,-1);
  else if(key==='arrowdown' || key==='s')pushDir(0,1);
  else if(key==='arrowleft' || key==='a')pushDir(-1,0);
  else if(key==='arrowright' || key==='d')pushDir(1,0);
});

let sx,sy;
canvas.addEventListener('touchstart',e=>{
  sx=e.touches[0].clientX;sy=e.touches[0].clientY;
},{passive:true});
canvas.addEventListener('touchend',e=>{
  const dx=e.changedTouches[0].clientX-sx;
  const dy=e.changedTouches[0].clientY-sy;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>20)pushDir(1,0); else if(dx<-20)pushDir(-1,0);
  } else {
    if(dy>20)pushDir(0,1); else if(dy<-20)pushDir(0,-1);
  }
});


restartBtn.onclick=()=>{reset();draw();};
reset();draw();requestAnimationFrame(loop);
</script>
</body>
</html>